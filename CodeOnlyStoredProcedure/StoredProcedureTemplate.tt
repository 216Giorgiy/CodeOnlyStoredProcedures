<#+
public class StoredProcedureTemplate : Template
{
	public int TypeCount;

	private void GetTypes(int count, bool escapeBrackets = false)
	{
		if (count == 0) return;

		if (escapeBrackets)
			Write("&lt;");
		else
			Write("<");
		for (int i = 1; i <= count; ++i)
		{
			if (i > 1)
				Write(", ");
			Write("T" + i);
		}

		if (escapeBrackets)
			Write("&gt;");
		else
			Write(">");
	}

	private void GetResults(bool isInXml = false)
	{
		if (TypeCount > 1)
        {			
			Write("Tuple");
			WriteOpen(isInXml);
        }

		for (int i = 1; i <= TypeCount; ++i)
		{
			if (i > 1)
				Write(", ");

			Write("IEnumerable");
			WriteOpen(isInXml);
			Write("T" + i);
			WriteClose(isInXml);
		}

		if (TypeCount > 1)
			WriteClose(isInXml);
	}

	private void WriteOpen(bool isInXml)
    {
		Write(isInXml ? "&lt;" : "<");
    }

	private void WriteClose(bool isInXml)
    {
		Write(isInXml ? "&gt;" : ">");
    }

	public void WriteTypeParams()
    {
        for (int i = 1; i <= TypeCount; i++)
        {
			if (i > 1)
				Write("\t");
			Write("/// <typeparam name=\"T" + i + "\">The type of the " + GetOrdinal(i) + " result set returned by the stored procedure.</typeparam>\n");
        }
    }

	public string GetOrdinal(int i)
    {
        switch (i)
        {
			case 1:
				return "first";

			case 2:
				return "second";

			case 3:
				return "third";

			case 4:
				return "fourth";

			case 5:
				return "fifth";

			case 6:
				return "sixth";

			case 7:
				return "seventh";

			default:
				return i + "th";
        }
    }

	public void WriteTypeChecks()
    {
		PushIndent("\t\t\t");

        for (int i = 1; i <= TypeCount; i++)
        {
			if (i > 1 )
				WriteLine("");
			Write("Contract.Requires(typeof(T" + i + ").IsValidResultType());");
        }

		PopIndent();
    }

	public void WriteReadResults(string indent)
    {
		PushIndent(indent);

		WriteLine("var dbParameters = AddParameters(cmd);");
		WriteLine("");
		WriteLine("token.ThrowIfCancellationRequested();");
		WriteLine("");
		WriteLine("var reader = cmd.ExecuteReader();");

		if (TypeCount == 1)
        {
			WriteLine("results = T1Factory.ParseRows(reader, DataTransformers, token);");
			PopIndent();
			return;
        }

		for (int i = 1; i <= TypeCount; ++i)
        {
			if (i > 1)
			{
				WriteLine("");
				WriteLine("reader.NextResult();");
				WriteLine("token.ThrowIfCancellationRequested();");
				WriteLine("");
			}

			WriteLine("var t" + i + " = T" + i + "Factory.ParseRows(reader, DataTransformers, token);");
        }

		Write("results = Tuple.Create(t1");
		
		for (int i = 2; i <= TypeCount; ++i)
			Write(", t" + i);

		WriteLine(");");
		
		WriteLine("");
		WriteLine("token.ThrowIfCancellationRequested();");
		WriteLine("");
		WriteLine("TransferOutputParameters(CancellationToken.None, dbParameters);");

		PopIndent();
    }

	public void WriteReadResultsAsync()
    {
		PushIndent("\t\t\t");
		if (TypeCount == 1)
        {
			WriteLine("results = await T1Factory.ParseRowsAsync(reader, DataTransformers, token);");
			PopIndent();
			return;
        }

		for (int i = 1; i <= TypeCount; ++i)
		{
			if (i > 1)
				WriteLine("await reader.NextResultAsync(token);");

			WriteLine("var t" + i + " = await T" + i + "Factory.ParseRowsAsync(reader, DataTransformers, token);");
        }

		Write("results = Tuple.Create(t1");
		
		for (int i = 2; i <= TypeCount; ++i)
			Write(", t" + i);

		WriteLine(");");
		PopIndent();
    }

    public override string TransformText()
    {
#>
	#region StoredProcedure<#+ GetTypes(TypeCount); #>

	/// <summary>Calls a StoredProcedure that returns <#+ Write(TypeCount.ToString()); #> result set(s).</summary>
	<#+ WriteTypeParams(); #>
	public class StoredProcedure<#+ GetTypes(TypeCount); #> : StoredProcedure<#+ GetTypes(TypeCount - 1); #>
	{
		private IRowFactory<T<#+ Write(TypeCount.ToString()); #>> factory;

		internal IRowFactory<T<#+ Write(TypeCount.ToString()); #>> T<#+ Write(TypeCount.ToString()); #>Factory 
		{
			get
			{
				if (factory == null)
					factory = RowFactory<T<#+ Write(TypeCount.ToString()); #>>.Create();

				return factory;
			}
		}

        /// <summary>
        /// Creates a <see cref="StoredProcedure"/> with the given <paramref name="name"/>
        /// in the dbo schema.
        /// </summary>
        /// <param name="name">The name of the stored procedure.</param>
		public StoredProcedure(string name) : base(name)
		{ 
            Contract.Requires(!string.IsNullOrWhiteSpace(name));
			<#+ WriteTypeChecks(); #>	
		}
		
        /// <summary>
        /// Creates a <see cref="StoredProcedure"/> with the given <paramref name="name"/>
        /// in the <paramref name="schema"/> schema.
        /// </summary>
        /// <param name="schema">The schema of the stored procedure.</param>
        /// <param name="name">The name of the stored procedure.</param>
		public StoredProcedure(string schema, string name) : base(schema, name)
		{ 
            Contract.Requires(!string.IsNullOrWhiteSpace(schema));
            Contract.Requires(!string.IsNullOrWhiteSpace(name));
			<#+ WriteTypeChecks(); #>	
		}
		
		internal StoredProcedure(StoredProcedure toClone)
			: base(toClone.Schema, toClone.Name, toClone.Parameters, toClone.DataTransformers) 
		{ 
			Contract.Requires(toClone != null);
		}
				
        /// <summary>
        /// Creates a <see cref="StoredProcedure"/> with the given <paramref name="name"/>
        /// in the <paramref name="schema"/> schema, with the <see cref="IStoredProcedureParameter"/>s
        /// to pass, the output action map, and the <see cref="IDataTransformer"/>s to 
        /// use to transform the results.
        /// </summary>
        /// <param name="schema">The schema of the stored procedure.</param>
        /// <param name="name">The name of the stored procedure.</param>
        /// <param name="parameters">The <see cref="IStoredProcedureParameter"/>s to pass to the stored procedure.</param>
        /// <param name="dataTransformers">The <see cref="IDataTransformer"/>s to transform the results.</param>
		protected StoredProcedure(string schema, 
            string name,
            IEnumerable<IStoredProcedureParameter> parameters,
			IEnumerable<IDataTransformer> dataTransformers)
			: base(schema, name, parameters, dataTransformers)
        {
            Contract.Requires(!string.IsNullOrWhiteSpace(schema));
            Contract.Requires(!string.IsNullOrWhiteSpace(name));
			Contract.Requires(parameters       != null);
			Contract.Requires(dataTransformers != null);
		}
	
        /// <summary>
        /// Executes the stored procedure.
        /// </summary>
        /// <param name="connection">The connection to use to execute the StoredProcedure.</param>
        /// <param name="timeout">The number of seconds to wait before aborting the 
        /// stored procedure's execution.</param>
		/// <returns>The results from the stored procedure.</returns>
        /// <example>If using from an Entity Framework DbContext, the connection can be passed:
        /// <code language='cs'>
        /// var results = storedProcedure.Execute(this.Database.Connection);
        /// </code>
        /// </example>
		public new <#+ GetResults(); #> Execute(IDbConnection connection, int timeout = defaultTimeout)
		{
			Contract.Requires(connection != null);
			Contract.Ensures(Contract.Result<<#+ GetResults(); #>>() != null);

			return Execute(connection, CancellationToken.None, timeout);
		}
		
		private <#+ GetResults(); #> Execute(IDbConnection connection, CancellationToken token, int timeout = defaultTimeout)
		{
			Contract.Requires(connection != null);
			Contract.Ensures(Contract.Result<<#+ GetResults(); #>>() != null);

			<#+ GetResults(); #> results;
			using (var cmd = connection.CreateCommand(Schema, Name, timeout, out connection))
            {
				<#+ WriteReadResults("\t\t\t\t"); #>
            }

            if (connection != null)
                connection.Close();
			
			return results;
		}
		
        /// <summary>
        /// Executes the StoredProcedure asynchronously.
        /// </summary>
        /// <param name="connection">The connection to use to execute the StoredProcedure.</param>
        /// <param name="timeout">The number of seconds to wait before aborting the 
        /// stored procedure's execution.</param>
        /// <returns>A Task&lt;<#+ GetResults(true); #>&gt; that will be completed when the StoredProcedure is finished executing.</returns>
        /// <example>If using from an Entity Framework DbContext, the connection can be passed:
        /// <code language='cs'>
        /// var results = await storedProcedure.ExecuteAsync(this.Database.Connection);
        /// </code>
        /// </example>
		public new Task<<#+ GetResults(); #>> ExecuteAsync(IDbConnection connection, int timeout = defaultTimeout)
		{
			Contract.Requires(connection != null);
			Contract.Ensures(Contract.Result<Task<<#+ GetResults(); #>>>() != null);

			return ExecuteAsync(connection, CancellationToken.None, timeout);
		}
		
        /// <summary>
        /// Executes the StoredProcedure asynchronously.
        /// </summary>
        /// <param name="connection">The connection to use to execute the StoredProcedure.</param>
        /// <param name="token">The <see cref="CancellationToken"/> to use to cancel the execution of the StoredProcedure.</param>
        /// <param name="timeout">The number of seconds to wait before aborting the 
        /// stored procedure's execution.</param>
        /// <returns>A Task&lt;<#+ GetResults(true); #>&gt; that will be completed when the StoredProcedure is finished executing.</returns>
        /// <example>If using from an Entity Framework DbContext, the connection can be passed:
        /// <code language='cs'>
		/// var cts     = new CancellationTokenSource();
        /// var results = await storedProcedure.ExecuteAsync(this.Database.Connection, cts.Token);
        /// </code>
        /// </example>
		public new Task<<#+ GetResults(); #>> ExecuteAsync(IDbConnection connection, CancellationToken token, int timeout = defaultTimeout)
		{
			Contract.Requires(connection != null);
			Contract.Ensures(Contract.Result<Task<<#+ GetResults(); #>>>() != null);
			
#if !NET40
            var baseClass = connection as DbConnection;
            if (baseClass != null)
            {
                IDbConnection toClose;
                var cmd = connection.CreateCommand(Schema, Name, timeout, out toClose);
                var asyncCapable = cmd as DbCommand;
                return ExecuteAsync(asyncCapable, toClose, token);
            }
#endif

			return Task.Factory.StartNew(
				() => Execute(connection, token, timeout), 
				token,
                TaskCreationOptions.None,
                TaskScheduler.Default);
		}
		
#if !NET40
		async Task<<#+ GetResults(); #>> ExecuteAsync(DbCommand cmd, IDbConnection toClose, CancellationToken token)
		{
			<#+ GetResults(); #> results;
            var dbParameters = AddParameters(cmd);
			
            token.ThrowIfCancellationRequested();
			var reader = await cmd.ExecuteReaderAsync(token);
			<#+ WriteReadResultsAsync(); #>

            token.ThrowIfCancellationRequested();
			TransferOutputParameters(token, dbParameters);

			if (toClose != null)
				toClose.Close();

			cmd.Dispose();

			return results;
		}
#endif

		
        /// <summary>
        /// Clones the StoredProcedure, and gives it the passed parameters.
        /// </summary>
        /// <param name="parameters">The <see cref="IStoredProcedureParameter"/>s to pass to the stored procedure.</param>
        /// <param name="dataTransformers">The <see cref="IDataTransformer"/>s to transform the results.</param>
        /// <returns>A clone of the stored procedure.</returns>
		protected internal override StoredProcedure CloneCore(
			IEnumerable<IStoredProcedureParameter> parameters,
			IEnumerable<IDataTransformer>          dataTransformers)
		{
			return new StoredProcedure<#+ GetTypes(TypeCount); #>(Schema, Name, parameters, dataTransformers);
		}	
	}
	#endregion


<#+
        return this.GenerationEnvironment.ToString();
    }
}
#>